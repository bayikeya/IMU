<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>IMU統合版：複数画像切替付きスポット案内（自動音声版） + カルマンフィルタ</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body { margin: 0; overflow: hidden; background-color: #000; color: white; font-family: sans-serif; text-align: center; }
    #camera { width: 100vw; height: 100vh; object-fit: cover; position: absolute; top: 0; left: 0; z-index: -1; }
    #info { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.6); padding: 10px; border-radius: 8px; z-index: 1; white-space: pre-wrap; font-size: 13px; }
    #image { position: absolute; bottom: 180px; left: 50%; transform: translateX(-50%); width: 300px; height: 300px; object-fit: contain; display: none; z-index: 1; background: black; }
    .btn { position: absolute; left: 50%; transform: translateX(-50%); background-color: #007BFF; color: white; border: none; padding: 10px 20px; font-size: 14px; border-radius: 8px; cursor: pointer; z-index: 2; display: none; }
    #patternBtn { bottom: 70px; }
    #nextBtn { bottom: 20px; }
    .img-nav { position: absolute; bottom: 260px; z-index: 2; font-size: 20px; background: rgba(0,0,0,0.5); color: white; border: none; padding: 5px 15px; cursor: pointer; border-radius: 6px; }
    #prevBtn { left: 10%; }
    #nextImgBtn { right: 10%; }
  </style>
</head>
<body>

<video id="camera" autoplay playsinline muted></video>
<div id="info">位置情報・IMU取得中...</div>
<img id="image" src="" alt="スポット画像" />
<button class="btn" id="patternBtn" onclick="switchPattern()">English</button>
<button class="btn" id="nextBtn" onclick="goToNextSpot()">このスポットは完了</button>
<button class="img-nav" id="prevBtn" onclick="showPrevImage()" style="display:none;">←</button>
<button class="img-nav" id="nextImgBtn" onclick="showNextImage()" style="display:none;">→</button>
<audio id="audio" src=""></audio>

<script>
/*
  変更点:
  - 単純なカルマンフィルタ（2D: x=east, y=north, vx, vy）を導入してGPSとIMU（歩行によるデッドレコニング）を融合します。
  - GPS測位が来たら更新（update）、IMUのステップで移動があるたびに予測（predict）を行います。
  - 表示にはフィルタ推定位置と推定誤差（共分散）を表示します。
  - 既存のロジックを大きく変えず、imuLat/imuLonをカルマンフィルタ出力で上書きしています。
*/

const spots = [
  { name: "13号館前", lat: 35.69302425885399, lon: 140.0508424409975, radius: 0, images: ["image0.jpeg", "image1.jpeg"], audio: { A: "spot1.ja.mp3", B: "spot1.en.mp3", C: "spot1.ch.mp3" } },
  { name: "曲がり角右", lat: 35.69283234340133, lon: 140.05091587321536, radius: 20, images: ["image3.jpeg", "image11.jpeg"], audio: { A: "spot3,4.ja.mp3", B: "spot3,4.en.mp3", C: "spot3,4.ch.mp3" } },
  { name: "曲がり角右１", lat: 35.69286877921128, lon:140.05030279528978, radius: 20, images: ["image4.jpeg", "image13.jpeg"], audio: { A: "spot3,4.ja.mp3", B: "spot3,4.en.mp3", C: "spot3,4.ch.mp3" } },
  { name: "曲がり角右２", lat: 35.69334894066289, lon:140.05033682451656, radius: 20, images: ["image5.jpeg", "image14.jpeg"], audio: { A: "spot5,6.ja.mp3", B: "spot5,6.en.mp3", C: "spot5,6.ch.mp3" } },
  { name: "曲がり角右３", lat: 35.69331981781718, lon:140.05102244720183, radius: 20, images: ["image6.jpeg", "image15.jpeg"], audio: { A: "spot5,6.ja.mp3", B: "spot5,6.en.mp3", C: "spot5,6.ch.mp3" } },
  { name: "目的地", lat: 35.693014464267506, lon:140.0509410980045, radius: 20, images: ["image7.jpeg", "image16.jpeg"], audio: { A: "spot7,8.ja.mp3", B: "spot7,8.en.mp3", C: "spot7,8.ch.mp3" } }
];

let currentIndex = 0;
let hasEnteredSpot = false;
let currentSpot = null;
let currentPattern = "A";
let imageIndex = 0;

let stepCount = 0;
let lastStepTime = 0;
let lastAccMag = 0;
let lastMoveTime = Date.now();
const STEP_LENGTH = 0.7; // 1歩あたり0.7m
const STEP_THRESHOLD = 1.2; // 加速度変化のしきい値
let currentSpeed = 0;

let lastUpdateTime = null;
let imuLat = null, imuLon = null; // 最終的にはカルマンフィルタ出力で上書き
let heading = 0; // 方位（度）

// UI elements
const camera = document.getElementById("camera");
const info = document.getElementById("info");
const image = document.getElementById("image");
const nextBtn = document.getElementById("nextBtn");
const patternBtn = document.getElementById("patternBtn");
const audio = document.getElementById("audio");
const prevBtn = document.getElementById("prevBtn");
const nextImgBtn = document.getElementById("nextImgBtn");

/* ---------------- カメラ起動 ---------------- */
navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" }, audio: false })
  .then(stream => camera.srcObject = stream)
  .catch(err => console.log("カメラへのアクセスに失敗しました: " + err));

/* ---------------- 距離計算（haversine） ---------------- */
function getDistance(lat1, lon1, lat2, lon2) {
  const R = 6371000;
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a = Math.sin(dLat/2)**2 + Math.cos(lat1*Math.PI/180) * Math.cos(lat2*Math.PI/180) * Math.sin(dLon/2)**2;
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

/* ---------------- カルマンフィルタ（シンプル4次元: x(East), y(North), vx, vy) ---------------- */
/*
  - 状態はメートル単位で保持。地球上の座標(lat, lon)はローカル近似でメートル変換を行う。
  - F (状態遷移) と H (観測行列) を使った線形カルマンフィルタ。
  - IMU（歩行による移動）を予測段階で直接位置変位として適用（制御入力のように扱う）。
*/
class SimpleKalman2D {
  constructor(lat0, lon0, opts = {}) {
    // 基準緯度での経度->メートルのスケール（簡易）
    this.refLat = lat0;
    this.cosRefLat = Math.cos(lat0 * Math.PI / 180);

    // 状態ベクトル [x, y, vx, vy] (m, m, m/s, m/s)
    this.x = [0, 0, 0, 0];

    // 初期位置をセット（lat/lon -> meters）
    const m = this.latLonToMeters(lat0, lon0);
    this.x[0] = m.x;
    this.x[1] = m.y;

    // 共分散行列 P (4x4)
    // 小さい値で自信がある初期化: 位置はGPSに依存するので中程度の不確かさ
    const posVar = (opts.initPosStd || 5) ** 2; // m^2
    const velVar = (opts.initVelStd || 1) ** 2;
    this.P = [
      [posVar,0,0,0],
      [0,posVar,0,0],
      [0,0,velVar,0],
      [0,0,0,velVar]
    ];

    // 観測ノイズ共分散 R （GPSの分散、m^2）
    this.R = [
      [(opts.gpsStd || 5) ** 2, 0],
      [0, (opts.gpsStd || 5) ** 2]
    ];

    // プロセスノイズ Q（4x4）
    const qPos = (opts.processPosStd || 0.5) ** 2;
    const qVel = (opts.processVelStd || 0.5) ** 2;
    this.Q = [
      [qPos,0,0,0],
      [0,qPos,0,0],
      [0,0,qVel,0],
      [0,0,0,qVel]
    ];

    // 最後にタイムスタンプ
    this.lastTs = null;
  }

  latLonToMeters(lat, lon) {
    // y: north (meters), x: east (meters)
    const y = lat * 111111.0;
    const x = lon * 111111.0 * this.cosRefLat;
    return { x, y };
  }

  metersToLatLon(x, y) {
    const lat = y / 111111.0;
    const lon = x / (111111.0 * this.cosRefLat);
    return { lat, lon };
  }

  // dt: 秒, dx, dy: メートルでのIMU推定変位（east,north）
  predict(dt, imu_dx = 0, imu_dy = 0) {
    if (dt <= 0) return;

    // 状態遷移（F）を考慮した単純な予測:
    // x_new = x + vx*dt + imu_dx
    // y_new = y + vy*dt + imu_dy
    // vx_new = vx (process noise will handle acceleration)
    // vy_new = vy
    this.x[0] += this.x[2] * dt + imu_dx;
    this.x[1] += this.x[3] * dt + imu_dy;
    // 更新速度はimuからも推測できる（単純に分母dt）
    if (dt > 0) {
      const vx_imu = imu_dx / dt;
      const vy_imu = imu_dy / dt;
      // 緩やかに速度を融合（ここでは単純平均っぽく）
      this.x[2] = 0.5 * (this.x[2] + vx_imu);
      this.x[3] = 0.5 * (this.x[3] + vy_imu);
    }

    // P の予測: P = F P F^T + Q
    // ここでF =
    // [1 0 dt 0
    //  0 1 0 dt
    //  0 0 1 0
    //  0 0 0 1]
    // Compute F*P*F^T quickly (manual multiply for 4x4 structure)
    const P = this.P;
    const dt2 = dt;
    // Build newP initialized with Q
    const newP = [
      [this.Q[0][0],0,0,0],
      [0,this.Q[1][1],0,0],
      [0,0,this.Q[2][2],0],
      [0,0,0,this.Q[3][3]]
    ];

    // Fill symmetric entries of F*P*F^T
    // newP[0][0] += P00 + dt*(P02 + P20) + dt^2 * P22
    newP[0][0] += P[0][0] + dt2*(P[0][2] + P[2][0]) + dt2*dt2*P[2][2];
    newP[0][1] += P[0][1] + dt2*(P[0][3] + P[2][1]) + dt2*dt2*P[2][3];
    newP[1][0] = newP[0][1];
    newP[1][1] += P[1][1] + dt2*(P[1][3] + P[3][1]) + dt2*dt2*P[3][3];

    newP[0][2] += P[0][2] + dt2*P[2][2];
    newP[2][0] = newP[0][2];
    newP[0][3] += P[0][3] + dt2*P[2][3];
    newP[3][0] = newP[0][3];

    newP[1][2] += P[1][2] + dt2*P[3][2];
    newP[2][1] = newP[1][2];
    newP[1][3] += P[1][3] + dt2*P[3][3];
    newP[3][1] = newP[1][3];

    newP[2][2] += P[2][2];
    newP[3][3] += P[3][3];
    newP[2][3] += P[2][3];
    newP[3][2] = newP[2][3];

    this.P = newP;
  }

  // GPS測位を使って更新（lat, lon 測定）
  update(lat_meas, lon_meas, measStd = 5.0) {
    // 観測をメートルに変換
    const m = this.latLonToMeters(lat_meas, lon_meas);
    const z = [m.x, m.y];

    // 観測行列 H = [1 0 0 0; 0 1 0 0]
    // S = H P H^T + R  (2x2)
    const P = this.P;

    // S00 = P00 + R00, S01 = P01 + R01 (R is diagonal)
    const R00 = (measStd ** 2);
    const R11 = (measStd ** 2);

    const S00 = P[0][0] + R00;
    const S01 = P[0][1] + 0;
    const S10 = P[1][0] + 0;
    const S11 = P[1][1] + R11;

    // Compute Kalman gain K = P H^T S^-1  (4x2)
    // K = [ P00 P01 ; P10 P11 ; P20 P21 ; P30 P31 ] * inv(S)
    const detS = S00 * S11 - S01 * S10;
    let invS = [[0,0],[0,0]];
    if (Math.abs(detS) < 1e-9) {
      // 数値的にまずい場合はスキップ
      return;
    } else {
      invS[0][0] =  S11 / detS;
      invS[0][1] = -S01 / detS;
      invS[1][0] = -S10 / detS;
      invS[1][1] =  S00 / detS;
    }

    const K = [
      [P[0][0]*invS[0][0] + P[0][1]*invS[1][0], P[0][0]*invS[0][1] + P[0][1]*invS[1][1]],
      [P[1][0]*invS[0][0] + P[1][1]*invS[1][0], P[1][0]*invS[0][1] + P[1][1]*invS[1][1]],
      [P[2][0]*invS[0][0] + P[2][1]*invS[1][0], P[2][0]*invS[0][1] + P[2][1]*invS[1][1]],
      [P[3][0]*invS[0][0] + P[3][1]*invS[1][0], P[3][0]*invS[0][1] + P[3][1]*invS[1][1]]
    ];

    // イノベーション y = z - Hx
    const y0 = z[0] - this.x[0];
    const y1 = z[1] - this.x[1];

    // 状態更新 x = x + K * y
    for (let i = 0; i < 4; i++) {
      this.x[i] += K[i][0] * y0 + K[i][1] * y1;
    }

    // 共分散更新 P = (I - K H) P
    // Compute (I - K H)
    const I_KH = [
      [1 - K[0][0], -K[0][1], 0, 0],
      [-K[1][0], 1 - K[1][1], 0, 0],
      [-K[2][0], -K[2][1], 1, 0],
      [-K[3][0], -K[3][1], 0, 1]
    ];

    // Multiply (I - K H) * P
    const newP = Array(4).fill(0).map(_ => Array(4).fill(0));
    for (let i = 0; i < 4; i++) {
      for (let j = 0; j < 4; j++) {
        let sum = 0;
        for (let k = 0; k < 4; k++) {
          sum += I_KH[i][k] * P[k][j];
        }
        newP[i][j] = sum;
      }
    }
    this.P = newP;
  }

  // state -> lat/lon
  getLatLon() {
    const pos = this.metersToLatLon(this.x[0], this.x[1]);
    return { lat: pos.lat, lon: pos.lon };
  }

  // 推定誤差（位置分散の平方根を返す、m単位）
  getPositionStd() {
    const sx2 = this.P[0][0];
    const sy2 = this.P[1][1];
    return { sx: Math.sqrt(Math.max(0, sx2)), sy: Math.sqrt(Math.max(0, sy2)) };
  }
}

// カルマンフィルタインスタンス（最初はnullで、初回GPS受信時に初期化）
let kf = null;

/* ---------------- スポット判定 ---------------- */
function checkProximity(lat, lon) {
  if (currentIndex >= spots.length) {
    info.innerText = "すべてのスポットを通過しました。";
    hideAllUI();
    return;
  }

  const spot = spots[currentIndex];
  const distance = getDistance(lat, lon, spot.lat, spot.lon);
  const range = spot.radius || 10;

  // カルマンの推定誤差も取得して表示
  let posStdText = "";
  if (kf) {
    const ps = kf.getPositionStd();
    posStdText = `推定誤差（m）: σx=${ps.sx.toFixed(1)}, σy=${ps.sy.toFixed(1)}\n`;
  }

  info.innerText =
    `IMU+Kalman補正位置: 緯度 ${lat.toFixed(6)}, 経度 ${lon.toFixed(6)}\n` +
    posStdText +
    `次のスポット: ${spot.name}（${currentIndex + 1} / ${spots.length}）\n` +
    `残り距離: ${distance.toFixed(1)}m\n`;

  // 現在のスポット判定（currentIndex >= 1 の判定を維持）
  if (currentIndex >= 1 && !hasEnteredSpot && distance < range) {
    showSpot(spot);
  }
}

/* ---------------- スポット表示 ---------------- */
function showSpot(spot) {
  currentSpot = spot;
  hasEnteredSpot = true;
  imageIndex = 0;

  audio.src = spot.audio[currentPattern];
  image.src = spot.images[imageIndex];
  image.style.display = "block";
  nextBtn.style.display = "block";
  patternBtn.style.display = "block";
  prevBtn.style.display = spot.images.length > 1 ? "block" : "none";
  nextImgBtn.style.display = spot.images.length > 1 ? "block" : "none";

  audio.loop = true;
  audio.play().catch(e => console.log("自動再生に失敗:", e));
}

/* ---------------- 音声パターン切替 ---------------- */
function switchPattern() {
  const patterns = ["A", "B", "C"];
  const index = patterns.indexOf(currentPattern);
  currentPattern = patterns[(index + 1) % patterns.length];
  updatePatternButtonText();

  if (currentSpot) {
    audio.pause();
    audio.src = currentSpot.audio[currentPattern];
    audio.play().catch(e => console.log("自動再生に失敗:", e));
  }
}

function updatePatternButtonText() {
  patternBtn.innerText = currentPattern === "A" ? "English" : currentPattern === "B" ? "中文" : "日本語";
}

/* ---------------- 画像切替 ---------------- */
function showPrevImage() {
  if (!currentSpot) return;
  imageIndex = (imageIndex - 1 + currentSpot.images.length) % currentSpot.images.length;
  image.src = currentSpot.images[imageIndex];
}
function showNextImage() {
  if (!currentSpot) return;
  imageIndex = (imageIndex + 1) % currentSpot.images.length;
  image.src = currentSpot.images[imageIndex];
}

/* ---------------- 次のスポットへ ---------------- */
function goToNextSpot() {
  audio.pause();
  currentIndex++;
  hasEnteredSpot = false;
  currentSpot = null;
  hideAllUI();
}

/* ---------------- UI 非表示 ---------------- */
function hideAllUI() {
  image.style.display = "none";
  nextBtn.style.display = "none";
  patternBtn.style.display = "none";
  prevBtn.style.display = "none";
  nextImgBtn.style.display = "none";
}

/* ---------------- IMU（加速度＋方位） ---------------- */
if (window.DeviceOrientationEvent) {
  window.addEventListener("deviceorientation", (event) => {
    if (event.absolute && event.alpha != null) {
      // alphaは0〜360、端末向きによる差があるので補正（北を0とする）
      heading = 360 - event.alpha;
    } else if (event.alpha != null) {
      // absoluteでない場合も使用（精度は下がる）
      heading = 360 - event.alpha;
    }
  });
}

if (window.DeviceMotionEvent) {
  window.addEventListener("devicemotion", (event) => {
    const acc = event.accelerationIncludingGravity;
    const now = Date.now();
    if (!lastUpdateTime || (!imuLat && !kf)) {
      lastUpdateTime = now;
      // まだ初期化がない場合はIMU予測は行えない
      lastAccMag = Math.sqrt((acc.x||0)**2 + (acc.y||0)**2 + (acc.z||0)**2);
      return;
    }

    const dt = (now - lastUpdateTime) / 1000;
    lastUpdateTime = now;

    // 加速度の大きさ
    const accMag = Math.sqrt((acc.x||0) ** 2 + (acc.y||0) ** 2 + (acc.z||0) ** 2);

    // ステップ検出（ピーク判定）
    if (accMag - lastAccMag > STEP_THRESHOLD && now - lastStepTime > 300) {
      stepCount++;
      stepInterval = (now - lastStepTime) / 1000;
      lastStepTime = now;
      lastMoveTime = now;

      // 歩行速度 = 歩幅 ÷ ステップ間隔
      currentSpeed = STEP_LENGTH / stepInterval;
      // 速度を4〜8km/hの範囲に制限（m/s）
      currentSpeed = Math.min(Math.max(currentSpeed, 1.1), 2.2);
    }

    lastAccMag = accMag;

    // 停止判定
    if (now - lastMoveTime > 2000) {
      currentSpeed = 0;
    }

    // 位置更新（IMUによるデッドレコニング） -> カルマンの予測に使用
    if (kf && currentSpeed > 0 && typeof heading === "number") {
      // heading をラジアンに
      const hdg = heading * Math.PI / 180;
      const distance = currentSpeed * dt; // m
      const dx_east = distance * Math.sin(hdg); // east
      const dy_north = distance * Math.cos(hdg); // north

      // カルマンの予測 (dt, imu_dx, imu_dy)
      kf.predict(dt, dx_east, dy_north);

      // カルマン推定位置を imuLat/imuLon に反映してスポット判定へ
      const est = kf.getLatLon();
      imuLat = est.lat;
      imuLon = est.lon;
      checkProximity(imuLat, imuLon);
    }
  });
}

/* ---------------- GPS ---------------- */
if ("geolocation" in navigator) {
  navigator.geolocation.watchPosition(
    pos => {
      const lat = pos.coords.latitude;
      const lon = pos.coords.longitude;
      const accuracy = pos.coords.accuracy || 5; // meters

      // 初回GPS受信でカルマンフィルタを初期化
      if (!kf) {
        kf = new SimpleKalman2D(lat, lon, {
          gpsStd: Math.max(accuracy, 3),
          initPosStd: Math.max(accuracy, 5),
          initVelStd: 1,
          processPosStd: 0.5,
          processVelStd: 0.5
        });
      } else {
        // 予測と更新: 時間差を計測して、先にpredictが呼ばれていればそのままupdate
        // ここでは単純にupdateを行う（GPSは観測）
        kf.update(lat, lon, Math.max(accuracy, 3));
      }

      // カルマンの推定位置を使う
      const est = kf.getLatLon();
      imuLat = est.lat;
      imuLon = est.lon;
      lastUpdateTime = Date.now();

      checkProximity(imuLat, imuLon);
    },
    err => {
      info.innerText = "位置情報の取得に失敗しました: " + (err.message || err.code);
      console.log("geolocation error:", err);
    },
    { enableHighAccuracy: true, maximumAge: 0, timeout: 5000 }
  );
} else {
  info.innerText = "このブラウザでは位置情報が利用できません。";
}

/* ---------------- 初期UI ---------------- */
window.onload = () => {
  // 既存の動作を尊重して最初のスポットを表示（案内のデモとして）
  // ただし、カルマンはGPS初回受信時に初期化されます。
  showSpot(spots[0]);
  updatePatternButtonText();
};
</script>

</body>
</html>
