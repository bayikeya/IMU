<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>IMU統合版：複数画像切替付きスポット案内（自動音声版）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body { margin: 0; overflow: hidden; background-color: #000; color: white; font-family: sans-serif; text-align: center; }
    #camera { width: 100vw; height: 100vh; object-fit: cover; position: absolute; top: 0; left: 0; z-index: -1; }
    #info { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.6); padding: 10px; border-radius: 8px; z-index: 2; white-space: pre-wrap; font-size: 13px; max-width: 48vw; }
    #debug { position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.6); padding: 10px; border-radius: 8px; z-index: 2; white-space: pre-wrap; font-size: 12px; text-align: left; max-width: 48vw; }
    #image { position: absolute; bottom: 180px; left: 50%; transform: translateX(-50%); width: 300px; height: 300px; object-fit: contain; display: none; z-index: 1; background: black; }
    .btn { position: absolute; left: 50%; transform: translateX(-50%); background-color: #007BFF; color: white; border: none; padding: 10px 20px; font-size: 14px; border-radius: 8px; cursor: pointer; z-index: 3; display: none; }
    #startBtn { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); z-index: 4; display: block; }
    #patternBtn { bottom: 70px; }
    #nextBtn { bottom: 20px; }
    .img-nav { position: absolute; bottom: 260px; z-index: 3; font-size: 20px; background: rgba(0,0,0,0.5); color: white; border: none; padding: 5px 15px; cursor: pointer; border-radius: 6px; }
    #prevBtn { left: 10%; }
    #nextImgBtn { right: 10%; }
    #controls { position: absolute; bottom: 140px; left: 10px; z-index: 3; background: rgba(0,0,0,0.5); padding: 8px; border-radius: 8px; font-size: 12px; }
    input[type=range] { width: 120px; }
  </style>
</head>
<body>

<video id="camera" autoplay playsinline muted></video>
<div id="info">タップして開始してください（センサー許可を要求します）</div>
<div id="debug" style="display:none;"></div>

<img id="image" src="" alt="スポット画像" />
<button class="btn" id="patternBtn" onclick="switchPattern()">English</button>
<button class="btn" id="nextBtn" onclick="goToNextSpot()">このスポットは完了</button>
<button class="img-nav" id="prevBtn" onclick="showPrevImage()" style="display:none;">←</button>
<button class="img-nav" id="nextImgBtn" onclick="showNextImage()" style="display:none;">→</button>
<audio id="audio" src=""></audio>

<button id="startBtn" class="btn" onclick="startApp()">アプリを開始する</button>

<div id="controls" style="display:none;">
  歩幅係数: <input id="strideScale" type="range" min="0.6" max="1.4" step="0.01" value="1"> <span id="strideVal">1.00</span><br>
  補正ゲイン: <input id="fusionGain" type="range" min="0.01" max="0.6" step="0.01" value="0.12"> <span id="fusionVal">0.12</span>
</div>

<script>
/* === スポットデータ（例） === */
const spots = [
  { name: "13号館前", lat: 35.69302425885399, lon: 140.0508424409975, radius: 10, images: ["image0.jpeg", "image1.jpeg"], audio: { A: "spot1.ja.mp3", B: "spot1.en.mp3", C: "spot1.ch.mp3" } },
  { name: "曲がり角右", lat: 35.69283234340133, lon: 140.05091587321536, radius: 20, images: ["image3.jpeg", "image11.jpeg"], audio: { A: "spot3,4.ja.mp3", B: "spot3,4.en.mp3", C: "spot3,4.ch.mp3" } },
  { name: "曲がり角右１", lat: 35.69286877921128, lon:140.05030279528978, radius: 20, images: ["image4.jpeg", "image13.jpeg"], audio: { A: "spot3,4.ja.mp3", B: "spot3,4.en.mp3", C: "spot3,4.ch.mp3" } },
  { name: "曲がり角右２", lat: 35.69334894066289, lon:140.05033682451656, radius: 20, images: ["image5.jpeg", "image14.jpeg"], audio: { A: "spot5,6.ja.mp3", B: "spot5,6.en.mp3", C: "spot5,6.ch.mp3" } },
  { name: "曲がり角右３", lat: 35.69331981781718, lon:140.05102244720183, radius: 20, images: ["image6.jpeg", "image15.jpeg"], audio: { A: "spot5,6.ja.mp3", B: "spot5,6.en.mp3", C: "spot5,6.ch.mp3" } },
  { name: "目的地", lat: 35.693014464267506, lon:140.0509410980045, radius: 20, images: ["image7.jpeg", "image16.jpeg"], audio: { A: "spot7,8.ja.mp3", B: "spot7,8.en.mp3", C: "spot7,8.ch.mp3" } }
];

/* === 状態変数 === */
let currentIndex = 0;
let hasEnteredSpot = false;
let currentSpot = null;
let currentPattern = "A";
let imageIndex = 0;

let stepCount = 0;
let lastStepTime = 0;
let lastAccMag = 0;
let lastMoveTime = Date.now();
let currentSpeed = 0;
let imuLat = null, imuLon = null; // IMUで推定される位置
let gpsLat = null, gpsLon = null, gpsAcc = null;
let heading = 0; // 方位（度）
let smoothedHeading = 0;
let lastUpdateTime = null;
let strideScale = 1.0;
let fusionGain = 0.12; // GPS -> IMU 補正ゲイン（0..1）, UIで調整可能

/* === UI 要素 === */
const camera = document.getElementById("camera");
const info = document.getElementById("info");
const debug = document.getElementById("debug");
const image = document.getElementById("image");
const nextBtn = document.getElementById("nextBtn");
const patternBtn = document.getElementById("patternBtn");
const audio = document.getElementById("audio");
const prevBtn = document.getElementById("prevBtn");
const nextImgBtn = document.getElementById("nextImgBtn");
const startBtn = document.getElementById("startBtn");
const controls = document.getElementById("controls");
const strideScaleEl = document.getElementById("strideScale");
const strideVal = document.getElementById("strideVal");
const fusionEl = document.getElementById("fusionGain");
const fusionVal = document.getElementById("fusionVal");

/* === カメラ起動はユーザー操作から === */
function startApp() {
  startBtn.style.display = "none";
  controls.style.display = "block";
  debug.style.display = "block";
  info.innerText = "センサー許可を要求中...";

  // カメラ起動
  navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" }, audio: false })
    .then(stream => camera.srcObject = stream)
    .catch(err => {
      console.warn("カメラ取得失敗:", err);
      info.innerText = "カメラへのアクセスに失敗しました: " + err;
    });

  // iOS / 一部ブラウザ向けにDeviceMotionEvent/DeviceOrientationEventの許可を要求
  const p1 = (typeof DeviceMotionEvent !== "undefined" && typeof DeviceMotionEvent.requestPermission === "function")
    ? DeviceMotionEvent.requestPermission().then(r => r === 'granted').catch(()=>false)
    : Promise.resolve(true);
  const p2 = (typeof DeviceOrientationEvent !== "undefined" && typeof DeviceOrientationEvent.requestPermission === "function")
    ? DeviceOrientationEvent.requestPermission().then(r => r === 'granted').catch(()=>false)
    : Promise.resolve(true);

  Promise.all([p1, p2]).then(results => {
    const ok = results[0] && results[1];
    if (!ok) {
      info.innerText = "センサー許可が必要です（ブラウザ設定をご確認ください）。";
      return;
    }
    info.innerText = "センサー許可が得られました。位置情報取得を開始します...";
    attachSensors();
    startGeolocation();
    // 初期スポットを表示（QR起動時は開始地点がスポット0の近辺である想定）
    currentIndex = 0;
    showSpot(spots[0]);
    updatePatternButtonText();
  }).catch(err => {
    console.warn("permission error", err);
    info.innerText = "センサー許可に失敗しました: " + err;
  });
}

/* === フィルタ／ユーティリティ関数 === */
// 単純ローパス: y = alpha * x + (1-alpha) * y_prev
function lowpass(prev, x, alpha) {
  if (prev === null || prev === undefined) return x;
  return alpha * x + (1 - alpha) * prev;
}

// ハバースィン距離
function getDistance(lat1, lon1, lat2, lon2) {
  const R = 6371000;
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a = Math.sin(dLat/2)**2 + Math.cos(lat1*Math.PI/180) * Math.cos(lat2*Math.PI/180) * Math.sin(dLon/2)**2;
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

/* === センサ取り付け・歩数検出とIMUデッドレコニング（簡易PDR） === */
let accBuffer = []; // 最近の加速度大きさのウィンドウ
const ACC_WINDOW_MS = 800;
function attachSensors() {
  // DeviceOrientation で方位（alpha）が得られる
  if (window.DeviceOrientationEvent) {
    window.addEventListener("deviceorientation", (event) => {
      // absoluteが使えるならそれを優先
      let a = event.alpha;
      if (a === null || a === undefined) return;
      // デバイス固有の反転や方位系の違いを吸収（北=0）
      heading = 360 - a;
      // スムーズにする
      smoothedHeading = lowpass(smoothedHeading, heading, 0.3);
    }, true);
  }

  // DeviceMotion で加速度
  if (window.DeviceMotionEvent) {
    window.addEventListener("devicemotion", (event) => {
      const now = Date.now();

      // 可能なら重力除去済みの値を使う（event.acceleration）
      const accObj = event.acceleration && event.acceleration.x !== null ? event.acceleration : event.accelerationIncludingGravity;
      if (!accObj) return;

      const ax = accObj.x || 0;
      const ay = accObj.y || 0;
      const az = accObj.z || 0;
      const accMag = Math.sqrt(ax*ax + ay*ay + az*az);

      // ウィンドウに保持して動的閾値を算出
      accBuffer.push({t: now, v: accMag});
      // バッファ古いものを削除
      while (accBuffer.length && now - accBuffer[0].t > ACC_WINDOW_MS) accBuffer.shift();

      // 平均・標準偏差を計算（単純）
      const vals = accBuffer.map(x => x.v);
      const mean = vals.reduce((a,b)=>a+b,0)/vals.length;
      const variance = vals.reduce((a,b)=>a+(b-mean)*(b-mean),0)/(vals.length || 1);
      const std = Math.sqrt(variance);

      // 動的閾値（平均 + k * std）
      const DYN_K = 1.0;
      const threshold = mean + DYN_K * std;

      // simple peak detection with debounce
      if (accMag > threshold && now - lastStepTime > 300) {
        // ステップ検出！
        stepCount++;
        const stepInterval = lastStepTime ? (now - lastStepTime)/1000 : 0.6;
        lastStepTime = now;
        lastMoveTime = now;

        // 歩幅推定（周期から推定、経験式）
        // 周期短 => 速歩 => 歩幅増加
        let estimatedStride = 0.65 + 0.1 * Math.min(Math.max(0.2/stepInterval, 0.0), 1.5); // 目安
        estimatedStride *= strideScale; // ユーザースケール
        // 制限
        estimatedStride = Math.max(0.4, Math.min(1.4, estimatedStride));

        currentSpeed = estimatedStride / Math.max(0.15, stepInterval); // m/s
        // 衝撃的な値のクリップ
        currentSpeed = Math.max(0, Math.min(3.0, currentSpeed));
      } else {
        // 停止判定
        if (now - lastMoveTime > 2000) {
          currentSpeed = 0;
        }
      }

      // 位置更新（簡易：歩幅と方位で更新。連続積分より安定）
      if (currentSpeed > 0 && imuLat !== null && imuLon !== null) {
        const dt = lastUpdateTime ? (now - lastUpdateTime)/1000 : 0.1;
        // distance = speed * dt
        const distance = currentSpeed * dt;
        const hdg = (smoothedHeading || heading) * Math.PI / 180;
        const dLat = (distance * Math.cos(hdg)) / 111111;
        const dLon = (distance * Math.sin(hdg)) / (111111 * Math.cos(imuLat * Math.PI / 180));
        imuLat += dLat;
        imuLon += dLon;
      }

      lastUpdateTime = now;
      // 近傍判定を行う
      if (imuLat !== null && imuLon !== null) checkProximity(imuLat, imuLon);
      updateDebug(mean, std, threshold);
    }, true);
  }
}

/* === GPS（位置） === */
let geoWatchId = null;
function startGeolocation() {
  if (!("geolocation" in navigator)) {
    info.innerText = "このブラウザでは位置情報が使用できません";
    return;
  }
  geoWatchId = navigator.geolocation.watchPosition(
    pos => {
      gpsLat = pos.coords.latitude;
      gpsLon = pos.coords.longitude;
      gpsAcc = pos.coords.accuracy; // meters
      lastUpdateTime = Date.now();

      // IMU位置が未初期化ならここで初期化（QRから起動のため初期位置はGPSが正）
      if (imuLat === null || imuLon === null) {
        imuLat = gpsLat;
        imuLon = gpsLon;
      } else {
        // GPSとIMUの融合（漸進的補正）
        // 補正ゲインは GPS 精度（小さいほど高精度）とUIでのfusionGainを使って決定
        // gain = fusionGain * (some factor inversely proportional to gpsAcc)
        const accFactor = Math.max(1, gpsAcc); // 精度が小さいほど補正を強めたい
        const gain = fusionGain * (1 / accFactor) * 10;
        const clampedGain = Math.max(0.01, Math.min(0.6, gain));

        imuLat = (1 - clampedGain) * imuLat + clampedGain * gpsLat;
        imuLon = (1 - clampedGain) * imuLon + clampedGain * gpsLon;
      }

      checkProximity(imuLat, imuLon);
      updateDebug();
    },
    err => {
      console.warn("geolocation error", err);
      info.innerText = "位置情報の取得に失敗しました: " + err.message;
    },
    { enableHighAccuracy: true, maximumAge: 1000, timeout: 5000 }
  );
}

/* === スポット判定 === */
function checkProximity(lat, lon) {
  if (currentIndex >= spots.length) {
    info.innerText = "すべてのスポットを通過しました。";
    hideAllUI();
    return;
  }

  const spot = spots[currentIndex];
  const distance = getDistance(lat, lon, spot.lat, spot.lon);
  const range = spot.radius || 10;

  info.innerText =
    `IMU補正位置: 緯度 ${lat.toFixed(6)}, 経度 ${lon.toFixed(6)}\n` +
    `GPS位置: ${gpsLat ? gpsLat.toFixed(6) + ',' + gpsLon.toFixed(6) + ' (±' + (gpsAcc?gpsAcc.toFixed(1):'---') + 'm)' : '未取得'}\n` +
    `方位(平滑): ${smoothedHeading.toFixed(1)}°\n` +
    `次のスポット: ${spot.name}（${currentIndex + 1} / ${spots.length}）\n` +
    `残り距離: ${distance.toFixed(1)}m\n` +
    `歩数: ${stepCount}, 速度: ${currentSpeed.toFixed(2)} m/s\n`;

  // 発見条件：現在は currentIndex>=1 のときだけ案内表示するようにしていたが、
  // 起点スポット(0)も意図的に表示できるようにするため、range内かつ未表示なら表示
  if (!hasEnteredSpot && distance < range) {
    showSpot(spot);
  }
}

/* === スポット表示 === */
function showSpot(spot) {
  currentSpot = spot;
  hasEnteredSpot = true;
  imageIndex = 0;

  audio.src = spot.audio[currentPattern];
  image.src = spot.images[imageIndex];
  image.style.display = "block";
  nextBtn.style.display = "block";
  patternBtn.style.display = "block";
  prevBtn.style.display = spot.images.length > 1 ? "block" : "none";
  nextImgBtn.style.display = spot.images.length > 1 ? "block" : "none";

  audio.loop = true;
  audio.play().catch(e => console.log("自動再生に失敗:", e));
}

/* === 音声パターン切替 === */
function switchPattern() {
  const patterns = ["A", "B", "C"];
  const index = patterns.indexOf(currentPattern);
  currentPattern = patterns[(index + 1) % patterns.length];
  updatePatternButtonText();

  if (currentSpot) {
    audio.pause();
    audio.src = currentSpot.audio[currentPattern];
    audio.play().catch(e => console.log("自動再生に失敗:", e));
  }
}
function updatePatternButtonText() {
  patternBtn.innerText = currentPattern === "A" ? "English" : currentPattern === "B" ? "中文" : "日本語";
}

/* === 画像切替 === */
function showPrevImage() {
  if (!currentSpot) return;
  imageIndex = (imageIndex - 1 + currentSpot.images.length) % currentSpot.images.length;
  image.src = currentSpot.images[imageIndex];
}
function showNextImage() {
  if (!currentSpot) return;
  imageIndex = (imageIndex + 1) % currentSpot.images.length;
  image.src = currentSpot.images[imageIndex];
}

/* === 次のスポットへ === */
function goToNextSpot() {
  audio.pause();
  currentIndex++;
  hasEnteredSpot = false;
  currentSpot = null;
  hideAllUI();
}

/* === UI 非表示 === */
function hideAllUI() {
  image.style.display = "none";
  nextBtn.style.display = "none";
  patternBtn.style.display = "none";
  prevBtn.style.display = "none";
  nextImgBtn.style.display = "none";
}

/* === デバッグ表示 === */
function updateDebug(mean, std, threshold) {
  const parts = [];
  parts.push(`IMU: ${imuLat?imuLat.toFixed(6):'---'}, ${imuLon?imuLon.toFixed(6):'---'}`);
  parts.push(`GPS: ${gpsLat?gpsLat.toFixed(6):'---'}, ${gpsLon?gpsLon.toFixed(6):'---'} (±${gpsAcc?gpsAcc.toFixed(1):'---'}m)`);
  parts.push(`heading: ${heading.toFixed(1)}°, smoothed: ${smoothedHeading.toFixed(1)}°`);
  parts.push(`speed: ${currentSpeed.toFixed(2)} m/s, steps: ${stepCount}`);
  if (mean !== undefined) parts.push(`acc mean:${mean.toFixed(2)} std:${std.toFixed(2)} thr:${threshold.toFixed(2)}`);
  parts.push(`fusionGain(UI): ${fusionGain.toFixed(2)}`);
  debug.innerText = parts.join("\n");
}

/* === コントロールUIのイベント === */
strideScaleEl.addEventListener('input', (e) => {
  strideScale = parseFloat(e.target.value);
  strideVal.innerText = strideScale.toFixed(2);
});
fusionEl.addEventListener('input', (e) => {
  fusionGain = parseFloat(e.target.value);
  fusionVal.innerText = fusionGain.toFixed(2);
});

/* === ページ読み込み時の処理 === */
window.onload = () => {
  // 初期UIは "開始" ボタンのみ
  updatePatternButtonText();
};
</script>

</body>
</html>
