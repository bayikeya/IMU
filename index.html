<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>IMU＋QR＋カルマン統合版：複数画像切替付きスポット案内</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body { margin: 0; overflow: hidden; background-color: #000; color: white; font-family: sans-serif; text-align: center; }
    #camera { width: 100vw; height: 100vh; object-fit: cover; position: absolute; top: 0; left: 0; z-index: -1; }
    #info { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.6); padding: 10px; border-radius: 8px; z-index: 1; white-space: pre-wrap; }
    #image { position: absolute; bottom: 180px; left: 50%; transform: translateX(-50%); width: 300px; height: 300px; object-fit: contain; display: none; z-index: 1; background: black; }
    .btn { position: absolute; left: 50%; transform: translateX(-50%); background-color: #007BFF; color: white; border: none; padding: 10px 20px; font-size: 14px; border-radius: 8px; cursor: pointer; z-index: 2; display: none; }
    #patternBtn { bottom: 70px; }
    #nextBtn { bottom: 20px; }
    .img-nav { position: absolute; bottom: 260px; z-index: 2; font-size: 20px; background: rgba(0,0,0,0.5); color: white; border: none; padding: 5px 15px; cursor: pointer; border-radius: 6px; }
    #prevBtn { left: 10%; }
    #nextImgBtn { right: 10%; }
  </style>
</head>
<body>

<video id="camera" autoplay playsinline muted></video>
<div id="info">位置情報・IMU取得中...</div>
<img id="image" src="" alt="スポット画像" />
<button class="btn" id="patternBtn" onclick="switchPattern()">English</button>
<button class="btn" id="nextBtn" onclick="goToNextSpot()">このスポットは完了</button>
<button class="img-nav" id="prevBtn" onclick="showPrevImage()" style="display:none;">←</button>
<button class="img-nav" id="nextImgBtn" onclick="showNextImage()" style="display:none;">→</button>
<audio id="audio" src=""></audio>

<script>
/* ---------------- スポット設定 ---------------- */
const spots = [
  { name: "13号館前", lat: 35.69302425885399, lon: 140.0508424409975, radius: 0, images: ["image0.jpeg", "image1.jpeg"], audio: { A: "spot1.ja.mp3", B: "spot1.en.mp3", C: "spot1.ch.mp3" } },
  { name: "曲がり角右", lat: 35.69283234340133, lon: 140.05091587321536, radius: 20, images: ["image3.jpeg", "image11.jpeg"], audio: { A: "spot3,4.ja.mp3", B: "spot3,4.en.mp3", C: "spot3,4.ch.mp3" } },
  { name: "目的地", lat: 35.693014464267506, lon:140.0509410980045, radius: 20, images: ["image7.jpeg", "image16.jpeg"], audio: { A: "spot7,8.ja.mp3", B: "spot7,8.en.mp3", C: "spot7,8.ch.mp3" } }
];

/* ---------------- 変数初期化 ---------------- */
let currentIndex = 0;
let hasEnteredSpot = false;
let currentSpot = null;
let currentPattern = "A";
let imageIndex = 0;
let imuLat = null, imuLon = null;
let heading = 0;
let lastUpdateTime = null;
let lastAccMag = 0, lastStepTime = 0, stepCount = 0;
let currentSpeed = 0, lastMoveTime = Date.now();

/* --- カルマンフィルタ変数 --- */
let state = { lat: null, lon: null }; // 推定位置
let P = 10; // 共分散
const Q = 0.0000005; // プロセスノイズ
const R = 0.000005;  // 観測ノイズ

const STEP_LENGTH = 0.7;
const STEP_THRESHOLD = 1.2;

const camera = document.getElementById("camera");
const info = document.getElementById("info");
const image = document.getElementById("image");
const nextBtn = document.getElementById("nextBtn");
const patternBtn = document.getElementById("patternBtn");
const audio = document.getElementById("audio");
const prevBtn = document.getElementById("prevBtn");
const nextImgBtn = document.getElementById("nextImgBtn");

/* ---------------- カメラ起動 ---------------- */
navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" }, audio: false })
  .then(stream => camera.srcObject = stream)
  .catch(err => alert("カメラへのアクセスに失敗しました: " + err));

/* ---------------- QR座標補正 ---------------- */
const params = new URLSearchParams(window.location.search);
if (params.has("lat") && params.has("lon")) {
  imuLat = parseFloat(params.get("lat"));
  imuLon = parseFloat(params.get("lon"));
  state.lat = imuLat;
  state.lon = imuLon;
  info.innerText = `QRコードで初期座標を補正しました。\nlat=${imuLat}, lon=${imuLon}`;
}

/* ---------------- haversine距離計算 ---------------- */
function getDistance(lat1, lon1, lat2, lon2) {
  const R = 6371000;
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a = Math.sin(dLat/2)**2 + Math.cos(lat1*Math.PI/180) * Math.cos(lat2*Math.PI/180) * Math.sin(dLon/2)**2;
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

/* ---------------- カルマンフィルタ ---------------- */
function kalmanUpdate(measuredLat, measuredLon) {
  if (state.lat == null || state.lon == null) {
    state.lat = measuredLat;
    state.lon = measuredLon;
    return;
  }

  // 予測ステップ
  P = P + Q;

  // 観測値更新
  const K = P / (P + R); // カルマンゲイン
  state.lat = state.lat + K * (measuredLat - state.lat);
  state.lon = state.lon + K * (measuredLon - state.lon);

  // 共分散更新
  P = (1 - K) * P;
}

/* ---------------- スポット距離判定 ---------------- */
function checkProximity(lat, lon) {
  if (currentIndex >= spots.length) {
    info.innerText = "すべてのスポットを通過しました。";
    hideAllUI();
    return;
  }

  const spot = spots[currentIndex];
  const distance = getDistance(lat, lon, spot.lat, spot.lon);
  const range = spot.radius || 10;

  info.innerText =
    `現在位置(統合後): 緯度 ${lat.toFixed(6)}, 経度 ${lon.toFixed(6)}\n` +
    `スポット: ${spot.name}（${currentIndex + 1}/${spots.length}）\n` +
    `距離: ${distance.toFixed(1)}m`;

  if (currentIndex >= 1 && !hasEnteredSpot && distance < range) {
    showSpot(spot);
  }
}

/* ---------------- スポット表示 ---------------- */
function showSpot(spot) {
  currentSpot = spot;
  hasEnteredSpot = true;
  imageIndex = 0;

  audio.src = spot.audio[currentPattern];
  image.src = spot.images[imageIndex];
  image.style.display = "block";
  nextBtn.style.display = "block";
  patternBtn.style.display = "block";
  prevBtn.style.display = spot.images.length > 1 ? "block" : "none";
  nextImgBtn.style.display = spot.images.length > 1 ? "block" : "none";

  audio.loop = true;
  audio.play().catch(e => console.log("自動再生に失敗:", e));
}

/* ---------------- 画像切替 ---------------- */
function showPrevImage() { if (currentSpot) { imageIndex = (imageIndex - 1 + currentSpot.images.length) % currentSpot.images.length; image.src = currentSpot.images[imageIndex]; } }
function showNextImage() { if (currentSpot) { imageIndex = (imageIndex + 1) % currentSpot.images.length; image.src = currentSpot.images[imageIndex]; } }

/* ---------------- 音声パターン切替 ---------------- */
function switchPattern() {
  const patterns = ["A", "B", "C"];
  currentPattern = patterns[(patterns.indexOf(currentPattern) + 1) % patterns.length];
  patternBtn.innerText = currentPattern === "A" ? "English" : currentPattern === "B" ? "中文" : "日本語";

  if (currentSpot) {
    audio.pause();
    audio.src = currentSpot.audio[currentPattern];
    audio.play().catch(e => console.log("再生失敗:", e));
  }
}

/* ---------------- 次のスポットへ ---------------- */
function goToNextSpot() {
  audio.pause();
  currentIndex++;
  hasEnteredSpot = false;
  hideAllUI();
}

/* ---------------- UI非表示 ---------------- */
function hideAllUI() {
  image.style.display = nextBtn.style.display = patternBtn.style.display = prevBtn.style.display = nextImgBtn.style.display = "none";
}

/* ---------------- IMU処理 ---------------- */
if (window.DeviceOrientationEvent) {
  window.addEventListener("deviceorientation", e => { if (e.alpha != null) heading = 360 - e.alpha; });
}
if (window.DeviceMotionEvent) {
  window.addEventListener("devicemotion", e => {
    const acc = e.accelerationIncludingGravity;
    const now = Date.now();
    if (!lastUpdateTime || !imuLat || !imuLon) { lastUpdateTime = now; return; }

    const dt = (now - lastUpdateTime) / 1000;
    lastUpdateTime = now;

    const accMag = Math.sqrt(acc.x**2 + acc.y**2 + acc.z**2);
    if (accMag - lastAccMag > STEP_THRESHOLD && now - lastStepTime > 300) {
      lastStepTime = now;
      stepCount++;
      currentSpeed = STEP_LENGTH / ((now - lastStepTime) / 1000);
      currentSpeed = Math.min(Math.max(currentSpeed, 1.0), 2.2);
      lastMoveTime = now;
    }
    lastAccMag = accMag;
    if (now - lastMoveTime > 2000) currentSpeed = 0;

    if (currentSpeed > 0 && heading && imuLat && imuLon) {
      const distance = currentSpeed * dt;
      const dLat = (distance * Math.cos(heading * Math.PI / 180)) / 111111;
      const dLon = (distance * Math.sin(heading * Math.PI / 180)) / (111111 * Math.cos(imuLat * Math.PI / 180));
      imuLat += dLat;
      imuLon += dLon;
      kalmanUpdate(imuLat, imuLon);
      checkProximity(state.lat, state.lon);
    }
  });
}

/* ---------------- GPS ---------------- */
if ("geolocation" in navigator) {
  navigator.geolocation.watchPosition(
    pos => {
      kalmanUpdate(pos.coords.latitude, pos.coords.longitude);
      imuLat = pos.coords.latitude;
      imuLon = pos.coords.longitude;
      checkProximity(state.lat, state.lon);
    },
    err => info.innerText = "位置情報取得に失敗: " + err.message,
    { enableHighAccuracy: true, maximumAge: 0, timeout: 5000 }
  );
}

/* ---------------- 初期動作 ---------------- */
window.onload = () => {
  showSpot(spots[0]);
  patternBtn.innerText = "English";
};
</script>
</body>
</html>
