<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>IMU 統合版（修正版）</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<style>
    body {
        margin: 0;
        overflow: hidden;
        background-color: #000;
        color: white;
        font-family: sans-serif;
        text-align: center;
    }

    #camera {
        width: 100vw;
        height: 100vh;
        object-fit: cover;
        position: absolute;
        top: 0;
        left: 0;
        z-index: -1;
    }

    #info {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.6);
        padding: 10px;
        border-radius: 8px;
        z-index: 1;
        white-space: pre-wrap;
    }

    #image {
        position: absolute;
        bottom: 180px;
        left: 50%;
        transform: translateX(-50%);
        width: 300px;
        height: 300px;
        object-fit: contain;
        display: none;
        z-index: 1;
        background: black;
    }

    .btn {
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
        background-color: #007BFF;
        color: white;
        border: none;
        padding: 10px 20px;
        font-size: 14px;
        border-radius: 8px;
        cursor: pointer;
        z-index: 2;
        display: none;
    }

    #patternBtn {
        bottom: 70px;
    }

    #nextBtn {
        bottom: 20px;
    }

    #startBtn {
        bottom: 120px;
        display: block;
    }

    /* 避難開始ボタン */
    .img-nav {
        position: absolute;
        bottom: 260px;
        z-index: 2;
        font-size: 20px;
        background: rgba(0, 0, 0, 0.5);
        color: white;
        border: none;
        padding: 5px 15px;
        cursor: pointer;
        border-radius: 6px;
    }

    #prevBtn {
        left: 10%;
    }

    #nextImgBtn {
        right: 10%;
    }
</style>
</head>
<body>
<!-- 略: 元の UI 要素（video, info, buttons, image, audio）をそのまま置く -->
<video id="camera" autoplay playsinline muted></video>
<div id="info">位置情報・IMU取得中...</div>
<img id="image" src="" alt="スポット画像" />
<button class="btn" id="patternBtn" onclick="switchPattern()">English</button>
<button class="btn" id="nextBtn" onclick="goToNextSpot()">このスポットは完了</button>
<button class="btn" id="startBtn" onclick="startEvacuation()">避難開始</button>
<button class="img-nav" id="prevBtn" onclick="showPrevImage()" style="display:none;">←</button>
<button class="img-nav" id="nextImgBtn" onclick="showNextImage()" style="display:none;">→</button>
<audio id="audio" src=""></audio>

<script>
/* --- 省略せずに元の spots 配列をここに入れてください --- */
const spots = [
            { name: "13号館前", lat: 35.69302425885399, lon: 140.0508424409975, radius: 0, images: ["image0.jpeg", "image1.jpeg"], audio: { A: "spot1.ja.mp3", B: "spot1.en.mp3", C: "spot1.ch.mp3" } },
            { name: "曲がり角右", lat: 35.69283234340133, lon: 140.05091587321536, radius: 20, images: ["image3.jpeg", "image11.jpeg"], audio: { A: "spot3,4.ja.mp3", B: "spot3,4.en.mp3", C: "spot3,4.ch.mp3" } },
            { name: "曲がり角右１", lat: 35.69286877921128, lon: 140.05030279528978, radius: 20, images: ["image4.jpeg", "image13.jpeg"], audio: { A: "spot3,4.ja.mp3", B: "spot3,4.en.mp3", C: "spot3,4.ch.mp3" } },
            { name: "曲がり角右２", lat: 35.69334894066289, lon: 140.05033682451656, radius: 20, images: ["image5.jpeg", "image14.jpeg"], audio: { A: "spot5,6.ja.mp3", B: "spot5,6.en.mp3", C: "spot5,6.ch.mp3" } },
            { name: "曲がり角右３", lat: 35.69331981781718, lon: 140.05102244720183, radius: 20, images: ["image6.jpeg", "image15.jpeg"], audio: { A: "spot5,6.ja.mp3", B: "spot5,6.en.mp3", C: "spot5,6.ch.mp3" } },
            { name: "目的地", lat: 35.693014464267506, lon: 140.0509410980045, radius: 20, images: ["image7.jpeg", "image16.jpeg"], audio: { A: "spot7,8.ja.mp3", B: "spot7,8.en.mp3", C: "spot7,8.ch.mp3" } }
        ];

let currentIndex = 0;
let hasEnteredSpot = false;
let currentSpot = null;
let currentPattern = "A";
let imageIndex = 0;

let stepCount = 0;
let lastStepTime = 0;
let lastAccMag = 0;
let STEP_LENGTH = 0.7;
let STEP_THRESHOLD = 1.2;

let lastUpdateTime = null;
let imuLat = null, imuLon = null;
let qrUsed = false;
let qrLat = null, qrLon = null;
let gpsBias = { lat: 0, lon: 0 };
let gpsBiasComputed = false;
let heading = null;

const camera = document.getElementById("camera");
const info = document.getElementById("info");
const image = document.getElementById("image");
const nextBtn = document.getElementById("nextBtn");
const patternBtn = document.getElementById("patternBtn");
const startBtn = document.getElementById("startBtn");
const audio = document.getElementById("audio");
const prevBtn = document.getElementById("prevBtn");
const nextImgBtn = document.getElementById("nextImgBtn");

/* QR読み取りによる初期位置取得（URL の lat lon を使う想定） */
function getQRInitialPosition() {
  const params = new URLSearchParams(window.location.search);
  const lat = parseFloat(params.get("lat"));
  const lon = parseFloat(params.get("lon"));
  if (!isNaN(lat) && !isNaN(lon)) {
    qrUsed = true;
    qrLat = lat;
    qrLon = lon;
    imuLat = lat;
    imuLon = lon;
    info.innerText = `QRコード補正済み位置: 緯度 ${lat.toFixed(6)}, 経度 ${lon.toFixed(6)}`;
    // 最初のスポットを QR に合わせる（必要なら）
    spots[0].lat = lat;
    spots[0].lon = lon;
  }
}

function startEvacuation() {
  getQRInitialPosition();

  currentIndex = 0;
  hasEnteredSpot = true;
  currentSpot = spots[0];
  imageIndex = 0;

  image.src = currentSpot.images[imageIndex];
  image.style.display = "block";
  nextBtn.style.display = "block";
  patternBtn.style.display = "block";
  prevBtn.style.display = currentSpot.images.length > 1 ? "block" : "none";
  nextImgBtn.style.display = currentSpot.images.length > 1 ? "block" : "none";

  audio.src = currentSpot.audio[currentPattern];
  audio.loop = true;
  audio.play().catch(e => console.log("自動再生に失敗:", e));

  // ここで IMU の積分を開始できるように時間だけ初期化しておく
  lastUpdateTime = Date.now();

  checkProximity(imuLat, imuLon);
  startBtn.style.display = "none";
}

/* カメラ取得 */
navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" }, audio: false })
  .then(stream => camera.srcObject = stream)
  .catch(err => console.log("カメラエラー:", err));

/* 距離計算（そのまま） */
function getDistance(lat1, lon1, lat2, lon2) {
  const R = 6371000;
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a = Math.sin(dLat / 2) ** 2 + Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLon / 2) ** 2;
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c;
}

function checkProximity(lat, lon) {
  if (currentIndex >= spots.length) {
    info.innerText = "すべてのスポットを通過しました。";
    hideAllUI();
    return;
  }
  if (lat == null || lon == null) return;
  const spot = spots[currentIndex];
  const distance = getDistance(lat, lon, spot.lat, spot.lon);
  const range = spot.radius || 10;
  info.innerText =
    `IMU補正位置: 緯度 ${lat.toFixed(6)}, 経度 ${lon.toFixed(6)}\n` +
    `次のスポット: ${spot.name}（${currentIndex + 1} / ${spots.length}）\n` +
    `残り距離: ${distance.toFixed(1)}m\n`;
  if (currentIndex >= 1 && !hasEnteredSpot && distance < range) {
    showSpot(spot);
  }
}

function showSpot(spot) {
  currentSpot = spot;
  hasEnteredSpot = true;
  imageIndex = 0;
  audio.src = spot.audio[currentPattern];
  image.src = spot.images[imageIndex];
  image.style.display = "block";
  nextBtn.style.display = "block";
  patternBtn.style.display = "block";
  prevBtn.style.display = spot.images.length > 1 ? "block" : "none";
  nextImgBtn.style.display = spot.images.length > 1 ? "block" : "none";
  audio.loop = true;
  audio.play().catch(e => console.log("自動再生に失敗:", e));
}

function switchPattern() {
  const patterns = ["A","B","C"];
  const index = patterns.indexOf(currentPattern);
  currentPattern = patterns[(index+1) % patterns.length];
  updatePatternButtonText();
  if (currentSpot) {
    audio.pause();
    audio.src = currentSpot.audio[currentPattern];
    audio.play().catch(e => console.log("自動再生に失敗:", e));
  }
}
function updatePatternButtonText() {
  patternBtn.innerText = currentPattern === "A" ? "English" : currentPattern === "B" ? "中文" : "日本語";
}

function showPrevImage(){ if(!currentSpot) return; imageIndex=(imageIndex-1+currentSpot.images.length)%currentSpot.images.length; image.src=currentSpot.images[imageIndex]; }
function showNextImage(){ if(!currentSpot) return; imageIndex=(imageIndex+1)%currentSpot.images.length; image.src=currentSpot.images[imageIndex]; }
function goToNextSpot(){ audio.pause(); currentIndex++; hasEnteredSpot=false; currentSpot=null; hideAllUI(); }
function hideAllUI(){ image.style.display="none"; nextBtn.style.display="none"; patternBtn.style.display="none"; prevBtn.style.display="none"; nextImgBtn.style.display="none"; }

/* DeviceOrientation（方位） */
if (window.DeviceOrientationEvent) {
  window.addEventListener("deviceorientation", (event) => {
    if (event.alpha != null) {
      // ここでは単純に alpha を代入（改良の余地あり: absolute 東西差の補正など）
      heading = 360 - event.alpha; // 元コードの向きの取り方を踏襲
      // heading を 0-360 に正規化
      if (heading < 0) heading += 360;
      if (heading >= 360) heading -= 360;
    }
  });
}

/* DeviceMotion（歩数検知 + 位置更新） */
if (window.DeviceMotionEvent) {
  window.addEventListener("devicemotion", (event) => {
    const acc = event.accelerationIncludingGravity;
    if (!acc) return;
    const now = Date.now();
    if (!lastUpdateTime) {
      lastUpdateTime = now;
      return;
    }
    const dt = (now - lastUpdateTime) / 1000;
    lastUpdateTime = now;
    const accMag = Math.sqrt((acc.x||0)**2 + (acc.y||0)**2 + (acc.z||0)**2);
    if (accMag - lastAccMag > STEP_THRESHOLD && now - lastStepTime > 300) {
      stepCount++;
      const stepInterval = (now - lastStepTime) / 1000;
      lastStepTime = now;
      lastMoveTime = now;
      // 簡易速度推定（平均歩幅 / stepInterval）
      let estimatedSpeed = STEP_LENGTH / Math.max(stepInterval, 0.2);
      // clamp（必要に応じて調整）
      estimatedSpeed = Math.min(Math.max(estimatedSpeed, 0.6), 2.2);
      // 移動距離
      const distance = estimatedSpeed * dt;
      // heading が数値であれば移動を適用
      if (typeof heading === 'number' && !Number.isNaN(heading) && imuLat != null && imuLon != null) {
        const dLat = (distance * Math.cos(heading * Math.PI / 180)) / 111111;
        const dLon = (distance * Math.sin(heading * Math.PI / 180)) / (111111 * Math.cos(imuLat * Math.PI / 180));
        imuLat += dLat;
        imuLon += dLon;
        checkProximity(imuLat, imuLon);
      }
    }
    lastAccMag = accMag;
  });
}

/* GPS（watchPosition） — QR 補正がある場合はバイアスを計算して適用 */
if ("geolocation" in navigator) {
  navigator.geolocation.watchPosition(
    pos => {
      const glat = pos.coords.latitude;
      const glon = pos.coords.longitude;
      // QR を使用して開始していて、まだバイアス未計算ならここでバイアスを算出
      if (qrUsed && !gpsBiasComputed && qrLat != null && qrLon != null) {
        gpsBias.lat = qrLat - glat;
        gpsBias.lon = qrLon - glon;
        gpsBiasComputed = true;
        console.log("GPS bias computed:", gpsBias);
      }
      // バイアスを適用して imuLat/imuLon を更新
      if (gpsBiasComputed) {
        imuLat = glat + gpsBias.lat;
        imuLon = glon + gpsBias.lon;
      } else {
        imuLat = glat;
        imuLon = glon;
      }
      lastUpdateTime = Date.now();
      checkProximity(imuLat, imuLon);
    },
    err => {
      info.innerText = "位置情報の取得に失敗しました: " + err.message;
    },
    { enableHighAccuracy: true, maximumAge: 0, timeout: 5000 }
  );
}

window.onload = () => {
  getQRInitialPosition();
  updatePatternButtonText();
};
</script>
</body>
</html>
